#!/usr/bin/env python3
"""
Doc Brown - Fully Autonomous HTML Assembler
Continuously monitors NATS for PAGE_SPEC conversion tasks
"""

import asyncio
import sys
import os
import re
from pathlib import Path
from datetime import datetime
from typing import Optional

# Add agent_coordination to path
sys.path.insert(0, '/Users/michaeljones/Dev/MJ_Online')
from agent_coordination.client import WorkerClient

# Constants
DESIGN_DIR = Path("/Users/michaeljones/Dev/MJ_Online/design")
CONTENT_DRAFTS_DIR = Path("/Users/michaeljones/Dev/MJ_Online/content-drafts")
AGENT_ID = "DocBrown-HTMLAssembler"

class HTMLConverter:
    """Converts PAGE_SPEC markdown to clean semantic HTML."""

    @staticmethod
    def convert_page_spec_to_html(spec_content: str, page_name: str) -> str:
        """
        Convert PAGE_SPEC to semantic HTML.

        Args:
            spec_content: Raw PAGE_SPEC markdown content
            page_name: Name of the page (for header comment)

        Returns:
            Clean semantic HTML string
        """
        html_parts = []

        # Add header comment
        html_parts.append(f"<!-- {page_name.upper()} -->")
        html_parts.append(f"<!-- Generated by: Doc Brown (Autonomous HTML Assembler) -->")
        html_parts.append(f"<!-- Date: {datetime.now().strftime('%Y-%m-%d %H:%M')} -->")
        html_parts.append(f"<!-- Source: PAGE_SPEC converted to semantic HTML -->")
        html_parts.append("")

        # Parse sections from PAGE_SPEC
        # This is a simplified parser - looks for content blocks and converts them

        lines = spec_content.split('\n')
        in_content_section = False
        current_section = []

        for line in lines:
            # Skip metadata and design notes
            if line.startswith('**') or line.startswith('---') or line.startswith('#'):
                if 'Content Requirements:' in line or 'SECTION' in line:
                    in_content_section = True
                elif line.startswith('##') and 'Design' in line:
                    in_content_section = False
                continue

            if in_content_section and line.strip():
                current_section.append(line.strip())

        # For now, return a note that manual conversion is needed
        # Real implementation would parse the spec more carefully
        html_parts.append("<p><strong>Note:</strong> This PAGE_SPEC requires manual review and conversion.</p>")
        html_parts.append(f"<p>Source: {page_name}</p>")

        return '\n'.join(html_parts)


class DocBrownAutonomous:
    """Autonomous Doc Brown HTML Assembler Agent."""

    def __init__(self):
        self.agent_id = AGENT_ID
        self.worker: Optional[WorkerClient] = None
        self.converter = HTMLConverter()
        self.running = True
        self.heartbeat_task = None

    async def heartbeat_loop(self):
        """Send heartbeat every 30 seconds."""
        while self.running:
            try:
                if self.worker:
                    await self.worker.heartbeat(
                        status="active",
                        current_task=None
                    )
                    print(f"‚ö° Heartbeat sent - {datetime.now().strftime('%H:%M:%S')}")
            except Exception as e:
                print(f"‚ö†Ô∏è Heartbeat error: {e}")

            await asyncio.sleep(30)

    async def find_page_spec(self, task_description: str) -> Optional[Path]:
        """
        Find the PAGE_SPEC file based on task description.

        Args:
            task_description: Task description from NATS

        Returns:
            Path to PAGE_SPEC file or None
        """
        # Look for PAGE_SPEC references in description
        if "substack" in task_description.lower():
            spec_file = DESIGN_DIR / "PAGE_SPEC-Substack-Landing.md"
            if spec_file.exists():
                return spec_file

        # Check for other specs
        for spec_file in DESIGN_DIR.glob("PAGE_SPEC-*.md"):
            page_name = spec_file.stem.replace("PAGE_SPEC-", "")
            if page_name.lower() in task_description.lower():
                return spec_file

        return None

    async def convert_to_html(self, spec_file: Path) -> tuple[str, Path]:
        """
        Convert PAGE_SPEC to HTML.

        Args:
            spec_file: Path to PAGE_SPEC markdown file

        Returns:
            Tuple of (HTML content, output file path)
        """
        print(f"üìñ Reading PAGE_SPEC: {spec_file.name}")
        spec_content = spec_file.read_text()

        # Extract page name
        page_name = spec_file.stem.replace("PAGE_SPEC-", "")

        # Convert to HTML
        print(f"‚öóÔ∏è Converting {page_name} to semantic HTML...")
        html_content = self.converter.convert_page_spec_to_html(spec_content, page_name)

        # Determine output filename
        output_file = CONTENT_DRAFTS_DIR / f"{page_name.lower().replace(' ', '-')}.html"

        return html_content, output_file

    async def process_task(self, task: dict):
        """
        Process a single HTML conversion task.

        Args:
            task: Task dictionary from NATS
        """
        task_id = task.get("task_id", "unknown")
        description = task.get("description", "")

        print(f"\n{'='*60}")
        print(f"üéØ Processing Task: {task_id}")
        print(f"{'='*60}")

        try:
            # Update heartbeat - working on task
            await self.worker.heartbeat(
                status="busy",
                current_task=task_id,
                current_task_title=task.get("title", "HTML Conversion")
            )

            # Find the PAGE_SPEC
            spec_file = await self.find_page_spec(description)

            if not spec_file:
                error_msg = f"‚ùå Could not find PAGE_SPEC for task: {task_id}"
                print(error_msg)
                await self.worker.complete_task(
                    task_id,
                    error=error_msg
                )
                return

            print(f"‚úÖ Found PAGE_SPEC: {spec_file}")

            # Convert to HTML
            html_content, output_file = await self.convert_to_html(spec_file)

            # Save HTML
            print(f"üíæ Saving HTML to: {output_file}")
            output_file.write_text(html_content)

            # Report success
            result = {
                "status": "completed",
                "summary": f"Converted {spec_file.name} to HTML",
                "deliverables": [str(output_file)],
                "spec_file": str(spec_file),
                "html_file": str(output_file),
                "ready_for_publishing": True,
                "next_agent": "Alice"
            }

            await self.worker.complete_task(task_id, result=result)

            # Notify coordination channel
            await self.worker.send_coordination_message(
                f"‚úÖ Doc Brown completed {task_id}: HTML saved to {output_file.name}. "
                f"Ready for @Alice to publish via Ghost Admin API."
            )

            print(f"‚úÖ Task {task_id} completed successfully!")
            print(f"üìÅ Output: {output_file}")

        except Exception as e:
            error_msg = f"Error processing task {task_id}: {str(e)}"
            print(f"‚ùå {error_msg}")
            await self.worker.complete_task(task_id, error=error_msg)
            await self.worker.report_error(error_msg)

        finally:
            # Clear current task from heartbeat
            await self.worker.heartbeat(
                status="active",
                current_task=None
            )

    async def run(self):
        """Main autonomous loop."""
        print("‚öóÔ∏è Doc Brown - Autonomous HTML Assembler Starting...")
        print(f"üïê {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("="*60)

        async with WorkerClient(self.agent_id) as worker:
            self.worker = worker

            # Register with NATS
            print("üì° Registering with NATS...")
            await worker.register(
                description="Autonomous HTML Assembler - Converts PAGE_SPECs to semantic HTML"
            )
            print("‚úÖ Registered successfully!")

            # Start heartbeat loop
            self.heartbeat_task = asyncio.create_task(self.heartbeat_loop())

            # Initial heartbeat
            await worker.heartbeat(status="active", current_task=None)

            # Send startup message
            await worker.send_coordination_message(
                f"‚öóÔ∏è Doc Brown online in AUTONOMOUS mode! "
                f"Monitoring NATS for HTML conversion tasks. "
                f"Task types: html_conversion, content_assembly, mobiledoc_assembly, PAGE_SPEC conversion."
            )

            print("\nüéß Listening for tasks...")
            print("Task types: html_conversion, content_assembly, mobiledoc_assembly")
            print("Keywords: html, PAGE_SPEC, convert, assembly, semantic\n")

            # Main monitoring loop
            while self.running:
                try:
                    # Get available tasks
                    tasks = await worker.get_available_tasks(limit=20)

                    # Filter for HTML conversion tasks
                    my_tasks = []
                    for task in tasks:
                        task_id = task.get("task_id", "")
                        desc = task.get("description", "").lower()

                        # Match task types or keywords
                        if any(keyword in desc for keyword in [
                            "html_conversion", "content_assembly", "mobiledoc_assembly",
                            "page_spec", "page-spec", "html", "convert", "semantic"
                        ]):
                            my_tasks.append(task)

                    if my_tasks:
                        print(f"\nüîî Found {len(my_tasks)} relevant task(s)!")

                        for task in my_tasks:
                            task_id = task.get("task_id", "unknown")

                            # Claim the task
                            print(f"üéØ Claiming task: {task_id}")
                            await worker.claim_task(task_id)

                            # Process the task
                            await self.process_task(task)

                    else:
                        # No tasks - idle
                        print(f"üí§ No tasks available - {datetime.now().strftime('%H:%M:%S')}", end='\r')

                    # Wait before next check
                    await asyncio.sleep(5)

                except KeyboardInterrupt:
                    print("\n\n‚ö†Ô∏è Received shutdown signal...")
                    self.running = False
                    break

                except Exception as e:
                    print(f"\n‚ö†Ô∏è Error in main loop: {e}")
                    await worker.report_error(f"Main loop error: {str(e)}")
                    await asyncio.sleep(10)  # Wait before retrying

            # Cleanup
            if self.heartbeat_task:
                self.heartbeat_task.cancel()

            # Final heartbeat
            await worker.heartbeat(status="offline", current_task=None)

            print("\n‚öóÔ∏è Doc Brown shutting down gracefully...")


async def main():
    """Entry point."""
    agent = DocBrownAutonomous()
    try:
        await agent.run()
    except KeyboardInterrupt:
        print("\n\nüõë Interrupted by user")
    except Exception as e:
        print(f"\n‚ùå Fatal error: {e}")
        raise


if __name__ == "__main__":
    print("‚ö°‚ö°‚ö° DOC BROWN - AUTONOMOUS HTML ASSEMBLER ‚ö°‚ö°‚ö°\n")
    asyncio.run(main())
